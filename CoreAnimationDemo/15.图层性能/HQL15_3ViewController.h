//
//  HQL15_3ViewController.h
//  CoreAnimationDemo
//
//  Created by Qilin Hu on 2019/9/27.
//  Copyright © 2019 Tonintech. All rights reserved.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

/// 绘制 3D 图层矩阵
@interface HQL15_3ViewController : UIViewController

@end

NS_ASSUME_NONNULL_END

/*
 # 混合和过渡绘制
 
 在第 12 章有提到，GPU 每一帧可以绘制的像素有一个最大限制（就是所谓的 fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。

     
 GPU 会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，你应该这样做：
 * 给视图的 backgroundColor 属性设置一个固定的，不透明的颜色
 * 设置 opaque 属性为 YES
 
 这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为。
 因为 Core Animation 可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。
     
 如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。
     
 如果是文本的话，一个白色背景的 UILabel（或者其他颜色）会比透明背景要更高效。
     
 最后，明智地使用 shouldRasterize 属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。
 
 # 减少图层数量
 
 初始化图层，处理图层，打包通过 IPC 发给渲染引擎，转化成 OpenGL 几何图形，这些是一个图层的大致资源开销。
 事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。
 
 确切的限制数量取决于 iOS 设备，图层类型，图层内容和属性等。
 但是总得说来可以容纳上百或上千个，下面我们将演示即使图层本身并没有做什么也会遇到的性能问题。
 
 
 ## 裁切
 
 在对图层做任何优化之前，你需要确定你不是在创建一些不可见的图层，图层在以下几种情况下会是不可见的：
 
 * 图层在屏幕边界之外，或是在父图层边界之外。
 * 完全在一个不透明图层之后。
 * 完全透明
 
 Core Animation 非常擅长处理对视觉效果无意义的图层。但是经常性地，你自己的代码会比 Core Animation 更早地想知道一个图层是否是有用的。理想状况下，在图层对象在创建之前就想知道，以避免创建和配置不必要图层的额外工作。
 
 
 
 */
